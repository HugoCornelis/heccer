#!/usr/bin/perl -w
#!/usr/bin/perl -d:ptkdb
##
##############################################################################
##'
##' Insert labels in a set of files.
##'
##' Copyright (C) 2006 Hugo Cornelis, hugo.cornelis@gmail.com
##'
##############################################################################


use strict;


use Getopt::Long;

use YAML ();


# parse options

my $option_help;
my $option_remove;
my $option_verbose;

sub read_cmd_line
{
    my $result
	= GetOptions
	    (
	     "help!" => \$option_help,
	     "r|remove!" => \$option_remove,
	     "v|verbose+" => \$option_verbose,
	    );

    if ($option_help)
    {
	print
	    "
$0: insert labels in a set of files.

options :
    help            print usage information.
    verbose         set verbosity level.
    remove          remove labels instead of insert.
";

	exit 1;
    }

}

read_cmd_line();


# get the package info

my $package = $ARGV[0] || '';
my $major = $ARGV[1] || '';
my $minor = $ARGV[2] || '';
my $micro = $ARGV[3] || '';
my $label = $ARGV[4] || '';
my $email = $ARGV[5] || '';

my $config
    = {
       files => [
		 './build-dist',
		 './configure.ac',
		 './glue/configure.ac',
		 './glue/swig/perl/configure.ac',
		 './tests/code/configure.ac',
		],
       labels => {
		  package => $package,
		  major => $major,
		  minor => $minor,
		  micro => $micro,
		  label => $label,
		  email => $email,
		 },
      };

my $files = $config->{files};

# loop over all files with keywords

foreach my $file (@$files)
{
    my $content;

    {
	# slurp content

	open my $descriptor, $file
	    or die $!;
	undef $/;
	$content = <$descriptor>;
	close $descriptor;
    }

    if ($content)
    {
	my $old_content = $content;

	# loop over source text

	while ($content =~ m/\G.*?\$Format: "([^\n]*)"\$/gs)
	{
	    my $position = pos($content);

	    # get matched string

	    my $matched = $1;

	    # if need to remove labels

	    if ($option_remove)
	    {
		$matched = '';
	    }

	    # else insert labels

	    else
	    {
		# check if info is available

		foreach my $info (keys %{$config->{labels}})
		{
		    if ($matched =~ /\$\{$info\}/
			&& !defined $config->{labels}->{$info})
		    {
			die "$0: '$info' keyword for file '$file' required but not defined";
		    }
		}

		# replace quotes

		#! not sure about quoting, probably not all cases covered.

		$matched =~ s/\\"/"/g;

		# replace variables

		foreach my $info (keys %{$config->{labels}})
		{
		    $matched =~ s/\$\{$info\}/$config->{labels}->{$info}/g;
		}
	    }

	    # replace the next line with the new text

	    $content =~ s/\G(.*\n).*\n/$1$matched\n/;

	    pos($content) = $position;
	}

	# if something has changed

	if ($old_content ne $content)
	{
	    # replace the file

	    open my $descriptor, ">$file"
		or die $!;
	    print $descriptor $content;
	    close $descriptor;
	}
    }
}

