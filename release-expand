#!/usr/bin/perl -w
#!/usr/bin/perl -d:ptkdb
#
#
# Generate a release
#


# get the package info

local $package = $ARGV[0] || '';
local $major = $ARGV[1] || '';
local $minor = $ARGV[2] || '';
local $micro = $ARGV[3] || '';
local $label = $ARGV[4] || '';
local $email = $ARGV[5] || '';

my $config
    = {
       files => [
		 './build-dist',
		 './configure.ac',
		 './glue/configure.ac',
		 './glue/swig/perl/configure.ac',
		 './tests/code/configure.ac',
		],
      };

my $files = $config->{files};

# loop over all files with keywords

foreach my $file (@$files)
{
    my $bd_text;

    {
	# slurp build-dist

	open my $bd, $file
	    or die $!;
	undef $/;
	$bd_text = <$bd>;
	close $bd;
    }

    if ($bd_text)
    {
	# loop over source text

	while ($bd_text =~ m/\G.*?\$Format: "([^\n]*)"\$/gs)
	{
	    my $position = pos($bd_text);

	    # get matched string

	    my $matched = $1;

	    # check if info is available

	    foreach my $info qw(package major minor micro label email)
	    {
		no strict "refs";

		if ($matched =~ /\$\{$info\}/
		    && $$info eq '')
		{
		    die "$0: $info keyword for file $file required but not defined";
		}
	    }

	    # replace quotes

	    #! not sure about quoting, probably not all cases covered.

	    $matched =~ s/\\"/"/g;

	    # replace variables

	    $matched =~ s/\$\{package\}/$package/g;
	    $matched =~ s/\$\{major\}/$major/g;
	    $matched =~ s/\$\{minor\}/$minor/g;
	    $matched =~ s/\$\{micro\}/$micro/g;
	    $matched =~ s/\$\{label\}/$label/g;
	    $matched =~ s/\$\{email\}/$email/g;

	    # replace the next line with the new text

	    $bd_text =~ s/\G(.*\n).*\n/$1$matched\n/;

	    pos($bd_text) = $position;
	}

	# replace the file

	open my $bd, ">$file"
	    or die $!;
	print $bd $bd_text;
	close $bd;
    }
}

