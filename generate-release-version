#!/usr/bin/perl -d:ptkdb
#!/usr/bin/perl -w
#!/usr/bin/perl -d:ptkdb
#
#
# Generate a release
#

use strict;


use YAML ();


# get the release name

my $release_name = $ARGV[0] || '';

#! made the release_name mandatory

if ($release_name eq '')
{
    die "$0: need a release name";
}

# check if there are any differences

my $inventory = [ map { chomp ; $_ } `mtn automate inventory` ];

#! see http://www.venge.net/monotone/docs/Automation.html#Automation, inventory command

my $missing = [ grep { /^  M/ } @$inventory ];

#! added or (added and patched)

my $added = [ grep { /^ A./ } @$inventory ];

my $dropped = [ grep { /^D  / } @$inventory ];

my $renamed_from = [ grep { /^R  / } @$inventory ];

my $renamed_to = [ grep { /^ R/ } @$inventory ];

my $patched = [ grep { /^  P/ } @$inventory ];

my $unchanged = [ grep { /^   / } @$inventory ];

my $unknown = [ grep { /^  U/ } @$inventory ];

my $ignored = [ grep { /^  I/ } @$inventory ];

if (@$missing
    || @$added
    || @$dropped
    || @$renamed_from
    || @$renamed_to
    || @$patched
    || @$unknown)
{
    die "$0: found uncommitted differences in this workspace, aborting";
}

# read the release database

my $package = YAML::LoadFile("package.yml");

# get releases

my $releases = $package->{releases} || {};

# # get all minors

# my $minors
#     = [
#        sort
#        map
#        {
# 	   $releases->{$_}->{minor}
#        }
#        keys %$releases,
#       ];

# # get all majors

# my $majors
#     = [
#        sort
#        map
#        {
# 	   $releases->{$_}->{major}
#        }
#        keys %$releases,
#       ];

# # figure out a next major/minor

# my $next_major = $majors->[$#$majors];

# if (!defined $next_major)
# {
#     #t check if I can get that using a cert mtn command.

#     my $options = `cat _MTN/options`;

#     #! e.g. branch "0"

#     $options =~ /branch\s*"(.*?)"/i;

#     $next_major = $1;
# }

# my $next_minor;

# if (!defined $next_minor)
# {
#     $next_minor = 1;
# }
# else
# {
#     $next_minor = $minors->[$#$minors] + 1;
# }

# construct a new record

my $email;

# if (exists $package->{branches}
#     && exists $package->{branches}->{$next_major}
#     && exists $package->{branches}->{$next_major}->{maintainer})
# {
#     $email = $package->{branches}->{$next_major}->{maintainer};
# }
# else
{
    $email = $package->{package}->{maintainer};
}

my $record
    = {
       email => $email,
#        major => $next_major,
#        minor => $next_minor,
       name => $release_name,
      };

# add the record

if (exists $releases->{$release_name})
{
    die "$0: this release ($release_name) is already in the release database";
}

$releases->{$release_name} = $record;

# link the new releases with the database

#! if there were no releases yet, $package and $releases are not
#! linked yet.

$package->{releases} = $releases;

# dump the new database

YAML::DumpFile("package.yml", $package);

# # figure out the current VC version

# #! this assumes that the log-message is not included in the SHA that
# #! makes up the revision id.

# # my $current = `mtn automate get_base_revision_id`;

# my $next_id = `mtn automate get_current_revision_id`;

# chomp $next_id;

#t replace the release names in configure.ac.



# put this release in the repository

system "mtn ci --message=\"$0: automated release with name ($release_name)\"";

if ($?)
{
    die "$0: commiting release database for $release_name failed";
}

# put a tag

my $current = `mtn automate get_base_revision_id`;

system "mtn tag $current \"$release_name\"";

if ($?)
{
    die "$0: failed to add a tag to the release made.";
}

