#!/usr/bin/perl -w
#!/usr/bin/perl -d:ptkdb
#
#
# Builds a distribution, including checks using automake and checks
# specific for this package
#

use strict;


use YAML ();


# get the release name

my $release_name = $ARGV[0] || '';

# check if there are any differences

my $inventory = [ map { chomp ; $_ } `mtn automate inventory` ];

#! see http://www.venge.net/monotone/docs/Automation.html#Automation, inventory command

my $missing = [ grep { /^  M/ } @$inventory ];

#! added or (added and patched)

my $added = [ grep { /^ A./ } @$inventory ];

my $dropped = [ grep { /^D  / } @$inventory ];

my $renamed_from = [ grep { /^R  / } @$inventory ];

my $renamed_to = [ grep { /^ R/ } @$inventory ];

my $patched = [ grep { /^  P/ } @$inventory ];

my $unchanged = [ grep { /^   / } @$inventory ];

my $unknown = [ grep { /^  U/ } @$inventory ];

my $ignored = [ grep { /^  I/ } @$inventory ];

if (@$missing
    || @$added
    || @$dropped
    || @$renamed_from
    || @$renamed_to
    || @$patched
    || @$unknown)
{
    die "$0: found uncommitted differences in this workspace, aborting";
}

# read the release database

my $releases = YAML::LoadFile("releases.yml");

# get versions

my $versions = $releases->{versions} || {};

# get all minors

my $minors
    = [
       sort
       map
       {
	   $versions->{$_}->{minor}
       }
       keys %$versions,
      ];

# get all majors

my $majors
    = [
       sort
       map
       {
	   $versions->{$_}->{major}
       }
       keys %$versions,
      ];

# figure out a next major/minor

my $next_major = $majors->[$#$majors];

if (!defined $next_major)
{
    #t check if I can get that using a cert mtn command.

    my $options = `cat _MTN/options`;

    #! e.g. branch "0"

    $options =~ /branch\s*".*?"/i;

    $next_major = $1;
}

my $next_minor;

if (!defined $next_minor)
{
    $next_minor = 1;
}
else
{
    $next_minor = $minors->[$#$minors] + 1;
}

# figure out the current VC version

my $current = `mtn automate get_base_revision_id`;

chomp $current;

# construct a new record

my $email;

if (exists $releases->{branches}->{$next_major}
    && exists $releases->{branches}->{$next_major}->{maintainer})
{
    $email = $releases->{branches}->{$next_major}->{maintainer};
}
else
{
    $email = $releases->{package}->{maintainer};
}

my $record
    = {
       email => $email,
       major => $next_major,
       minor => $next_minor,
       release_name => $release_name,
      };

# add the record

if (exists $versions->{$current})
{
    die "$0: this version ($current) is already in the release database";
}

$versions->{$current} = $record;

# add a record to map the release back to the major/minor

if (defined $release_name && $release_name ne '')
{
    my $release
	= {
	   name => $release_name,
	   id => $current,
	  };

    $releases->{releases}->{$release_name} = $release;
}

# put a tag

system "mtn tag $current $release_name";

if ($?)
{
    die "$0: failed to add a tag, no release made.";
}

# dump the new database

YAML::DumpFile("releases.yml", $versions);

# put this release in the repository

system "mtn ci --message=\"$0: automated release with name ($release_name)\"";

if ($?)
{
    die "$0: commiting release $release_name failed";
}

